---
phase: 01-security-foundation-and-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/transactions/route.ts
  - app/api/transactions/[id]/route.ts
  - __tests__/integration/security/cross-tenant-access.test.ts
autonomous: true

must_haves:
  truths:
    - 'Association user attempting to create transaction receives 403 Forbidden error'
    - 'Association user attempting to edit transaction receives 403 Forbidden error'
    - 'Association user attempting to delete transaction receives 403 Forbidden error'
    - 'Team treasurer can still create/edit/delete transactions normally'
    - 'Integration tests catch cross-tenant access attempts'
  artifacts:
    - path: 'app/api/transactions/route.ts'
      provides: 'POST endpoint with association user rejection'
      contains: 'if (isAssociationUser(user))'
      min_lines: 10
    - path: 'app/api/transactions/[id]/route.ts'
      provides: 'PATCH and DELETE endpoints with association user rejection'
      contains: 'if (isAssociationUser(user))'
      min_lines: 20
    - path: '__tests__/integration/security/cross-tenant-access.test.ts'
      provides: 'Integration tests for cross-tenant security'
      exports: ['describe']
      min_lines: 100
  key_links:
    - from: 'app/api/transactions/route.ts'
      to: 'lib/permissions/server-permissions.ts'
      via: 'isAssociationUser() import'
      pattern: "isAssociationUser\\(user\\)"
    - from: 'app/api/transactions/[id]/route.ts'
      to: 'lib/permissions/server-permissions.ts'
      via: 'isAssociationUser() import'
      pattern: "isAssociationUser\\(user\\)"
    - from: '__tests__/integration/security/cross-tenant-access.test.ts'
      to: 'app/api/transactions'
      via: 'API endpoint tests'
      pattern: "POST.*\\/api\\/transactions"
---

<objective>
Implement defense-in-depth security by explicitly rejecting mutation requests from association users and adding integration tests that verify cross-tenant isolation.

Purpose: Close the security gap where association users with TREASURER role (edge case) could potentially mutate transactions. Ensure Ontario association cannot access or modify Alberta association data.

Output: Hardened mutation endpoints with explicit role checks and automated security tests that prevent cross-tenant data leakage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-security-foundation-and-infrastructure/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md

# Existing permission utilities

@lib/permissions/server-permissions.ts

# Mutation endpoints to harden

@app/api/transactions/route.ts
@app/api/transactions/[id]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Explicit Association User Rejection to Mutation Endpoints</name>
  <files>
    app/api/transactions/route.ts
    app/api/transactions/[id]/route.ts
  </files>
  <action>
Add explicit association user checks to all transaction mutation endpoints (POST, PATCH, DELETE).

**For POST /api/transactions (route.ts):**

- After `getCurrentUser()` and null check, add association user check BEFORE existing TREASURER role check
- Use pattern from research: `if (isAssociationUser(user)) { return NextResponse.json({ error: 'Association users have read-only access to team data' }, { status: 403 }) }`
- Import `isAssociationUser` from `@/lib/permissions/server-permissions`
- Place check at line ~145 (after auth, before role check)

**For PATCH /api/transactions/[id] (route.ts in [id] directory):**

- After `getCurrentUser()` and null check, add association user check
- Same error message and 403 status
- Place before existing team ownership validation

**For DELETE /api/transactions/[id]:**

- After `getCurrentUser()` and null check, add association user check
- Same error message and 403 status
- Place before existing team ownership validation

**Why this pattern:**

- Defense-in-depth: Even if association user somehow has TREASURER role, mutations are blocked
- Explicit > implicit: Clear intent that association users are read-only
- Fail fast: Check role before expensive validation or database queries

**What NOT to do:**

- Don't rely on UI hiding buttons - server must enforce
- Don't combine with existing role checks using OR logic - separate concerns
- Don't check after team ownership validation - reject earlier to avoid data leakage
  </action>
  <verify>

1. Run TypeScript compiler: `npm run build` (must pass with no errors)
2. Search for all `isAssociationUser` calls in mutation endpoints:
   ```
   grep -n "isAssociationUser" app/api/transactions/route.ts app/api/transactions/[id]/route.ts
   ```
   Should show 3 occurrences (POST, PATCH, DELETE)
3. Verify error message consistency:
   ```
   grep -A 2 "isAssociationUser(user)" app/api/transactions/route.ts app/api/transactions/[id]/route.ts
   ```
   All three should return same 403 error message
4. Manual API behavior test: Use curl or Postman to POST to /api/transactions with association user credentials - should receive 403 with "read-only access" message
   </verify>
   <done>

- POST /api/transactions returns 403 for association users before role check
- PATCH /api/transactions/[id] returns 403 for association users before ownership check
- DELETE /api/transactions/[id] returns 403 for association users before ownership check
- All three endpoints use consistent error message
- TypeScript compilation succeeds
- Manual API test confirms 403 response with expected error message
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create Cross-Tenant Security Integration Tests</name>
  <files>
    __tests__/integration/security/cross-tenant-access.test.ts
  </files>
  <action>
Create comprehensive integration tests that verify association users cannot access other associations' data.

**Test file structure:**

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest'
import { prisma } from '@/lib/prisma'
// Import test utilities for API calls and auth mocking

describe('Cross-Tenant Security', () => {
  // Setup: Create two associations (Ontario, Alberta) with teams and transactions
  // Setup: Create association users for each association

  describe('Read Operations', () => {
    it('association user can query own teams', async () => {
      // Test GET /api/transactions with Ontario user -> Ontario teams
      // Verify returns transactions
    })

    it('association user cannot query other association teams via teamIds param', async () => {
      // Test GET /api/transactions?teamIds=alberta-team-id with Ontario user
      // Verify returns 403 or filters out Alberta teams
    })

    it('team user cannot query other teams', async () => {
      // Test GET /api/transactions with team user -> different team
      // Verify returns 403 or empty
    })
  })

  describe('Mutation Operations (SEC-03)', () => {
    it('association user cannot create transaction', async () => {
      // Test POST /api/transactions with association user
      // Verify returns 403 with "read-only access" message
    })

    it('association user cannot update transaction', async () => {
      // Test PATCH /api/transactions/[id] with association user
      // Verify returns 403 with "read-only access" message
    })

    it('association user cannot delete transaction', async () => {
      // Test DELETE /api/transactions/[id] with association user
      // Verify returns 403 with "read-only access" message
    })

    it('team treasurer can still create transaction', async () => {
      // Test POST /api/transactions with team TREASURER
      // Verify succeeds with 201
    })
  })

  describe('Multi-Team Query Filtering (SEC-01, SEC-02)', () => {
    it('filters requested team IDs to only accessible teams', async () => {
      // Test GET /api/transactions?teamIds=own-team,other-assoc-team
      // Verify only returns own team data
    })

    it('returns empty when no accessible teams in request', async () => {
      // Test GET /api/transactions?teamIds=other-assoc-team
      // Verify returns 403 or empty array
    })
  })
})
```

**Test data setup:**

- Create test associations: Ontario, Alberta
- Create test teams: 1 per association
- Create test transactions: 2 per team
- Create test users: association admin for each, treasurer for each team
- Use Vitest `beforeAll` for setup, `afterAll` for cleanup

**Authentication mocking approach:**

For this integration test, use one of the following approaches:

**Option 1: Direct Clerk API calls (if Clerk test API available):**

- Create test users via Clerk test API
- Get real auth tokens for API calls
- Clean up test users in afterAll

**Option 2: Mock Next.js auth context:**

- Use Next.js test utilities to mock `auth()` function
- Return mock user objects with required fields (userId, role, associations)
- Test without actual Clerk authentication

**Option 3: Create test authentication middleware:**

- Build minimal auth bypass for test environment only
- Use `NODE_ENV=test` guard to enable
- Pass user context via custom header (`X-Test-User-Id`)

Choose the approach that matches existing codebase patterns. If no testing infrastructure exists yet, use Option 2 (mock auth context) as it requires no external dependencies.

**Assertions:**

- Verify HTTP status codes (403, 200, 201)
- Verify error messages match expected patterns
- Verify data returned matches expected team scope
- Verify mutations are blocked, reads are scoped
  </action>
  <verify>

1. Run integration tests:
   ```
   npm run test:integration -- cross-tenant-access.test.ts
   ```
   All tests must pass
2. Check test coverage includes all mutation endpoints:
   ```
   grep -c "POST\\|PATCH\\|DELETE" __tests__/integration/security/cross-tenant-access.test.ts
   ```
   Should show at least 3 (one per mutation type)
3. Verify test creates multi-association scenario:
   ```
   grep -c "association" __tests__/integration/security/cross-tenant-access.test.ts
   ```
   Should show multiple references to association setup
   </verify>
   <done>

- Integration test file exists with cross-tenant security tests
- Tests cover SEC-01 (team ownership validation), SEC-02 (API validates team ownership), SEC-03 (mutation rejection)
- Tests verify association user mutation attempts return 403
- Tests verify team user can still mutate own transactions
- Tests verify cross-association data access is blocked
- All tests pass
  </done>
  </task>

</tasks>

<verification>
Run full test suite to ensure no regressions:
```bash
npm run test
npm run test:integration
```

Verify security requirements are met:

- SEC-01: Server-side permission checks enforce association scoping (tested)
- SEC-02: API validates team ownership before returning data (tested)
- SEC-03: Mutation endpoints explicitly reject association users (implemented and tested)

Verify no breaking changes for existing functionality:

- Team treasurers can still create/edit/delete transactions
- Association users can still read multi-team transaction data
- Existing transaction validation and approval flows unchanged
  </verification>

<success_criteria>

1. All mutation endpoints (POST, PATCH, DELETE) return 403 for association users with message "Association users have read-only access to team data"
2. Integration tests exist that attempt cross-tenant access and verify 403 responses
3. Integration tests verify team treasurers retain full mutation capabilities
4. All existing tests still pass (no regressions)
5. TypeScript compilation succeeds with no new errors
6. Security gap documented in research is closed
   </success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation-and-infrastructure/01-01-SUMMARY.md` following the summary template.
</output>
